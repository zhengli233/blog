---
title: 现代操作系统 第二章 进程与线程
top: false
cover: false
toc: true
mathjax: true
date: 2020-05-26 15:47:13
password:
summary:
tags:
categories: 操作系统
thumbnail:
---

## 进程
**进程的概念**
进程是操作系统提供的最古老也是最终要的抽象概念之一, 即使可以使用的cpu只有一个, 它们也具有支持(伪)并发操作的能力.
现代计算机经常会在同一时间做许多事情, 比如编辑文档时接收邮件, 又比如上网课时偷偷打游戏:). 然而cpu在同一时间只能运行一个进程, 那些看似并行的行为, 其实只是cpu在快速地从一个进程切换到另一个进程, 使每个进程各运行几十或几百毫秒, 让我们产生并行的错觉. 这种快速的切换称作多道程序设计.
![](/images/现代操作系统/多道程序设计.png)
<!--more-->
需要注意的是, 因为进程的执行会被cpu来回切换, 因此在写程序时, 我们不能去假设某条语句的运行时间.
进程和程序之间的关系在我看来类似容器和内容的关系. 进程提供给了程序运行所需要的内存资源和运算资源, 程序规定了这些资源应该如何使用.

**进程的创建**
4种主要事件会导致进程的创建:
1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新的进程
4. 一个批处理作业的初始化

在UNIX系统中, 只有一个系统调用来创建新进程: fork. 这个系统调用会创建一个与调用进程相同的副本. 在调用之后, 父进程和子进程拥有相同的内存映像,同样的环境字符串和同样的打开文件. 通常, 子进程接着执行execve或一个类似的系统调用, 以修改其内存映像并运行一个新的程序. 
在Windows中, 一个Win32函数调用CreateProcess既处理进程的创建, 也负责把正确的程序装入新的进程. 

无论哪种系统中, 进程创建后, 父进程和子进程拥有不用的地址空间. 因此进程修改在其地址空间中的字对其他进程是不可见的. 某些UNIX的实现可以让只读内存在进程间共享, 但可写内存一定是不共享的.

**进程的终止**
进程的终止通常由下列条件引起:
1. 正常退出(自愿)
2. 出错退出(自愿)
3. 严重错误(非自愿)
4. 被其他进程杀死(非自愿)

当进程完成了它的工作, 会执行一个系统调用通知系统. 在UNIX中该调用是exit, Windows中是ExitProcess. 
杀死进程的调用在UNIX中是kill, 在Windows中是TerminateProcess.

**进程的层次结构**
UNIX在初始化时, 一个称为init的特殊进程出现在启动映像中, 它读入一个说明终端数量的文件, 接着为每个终端创建一个新进程, 这些进程等待用户登录, 用户登录成功后, 就会执行一个shell准备接收命令, 从shell再去启动更多的进程. 因此, 这个系统中, 所有进程都是属于以init为根的一棵进程树.
Winodws中没有进程层次的概念, 所有进程都是地位相同的.

**进程状态**

![](/images/现代操作系统/进程状态.png)

进程的三种状态分别是:
1. 运行态(该时刻进程实际占用cpu)
2. 就绪态(可运行, 但cpu正在被其他进程占用)
3. 阻塞态(除非某种外部事件发生, 否则进程不能运行)

进程处在运行态还是就绪态是由调度程序决定的, 它是操作系统的一部分, 之后会详细讨论.
阻塞态是因为进程调用了诸如pause等系统调用或等待外部输入时而进入的.

**进程的实现**

![](/images/现代操作系统/进程表项中的一些字段.png)

为了实现进程模型, 操作系统维护这一张表格, 即进程表, 每个进程占用一个进程表项. 为了能实现多个进程的切换, 进程表项中需要保存切换所需要的信息, 如上图所示.

## 线程
线程相当于一个轻量的进程, 它也可以并行运行, 但不同的是, 线程之间共享地址空间.
我们使用线程有以下若干理由:
1. 许多应用场景会同时发生着多种活动, 引入线程会使我们的程序设计更加简单
2. 线程比进程更轻, 在许多系统中, 创建一个线程比创建一个进程要快10~100倍
3. 在存在大量计算和io的程序中, 使用线程能提高程序执行的速度
4. 在多cpu系统中, 真正的并行有了实现的可能, 因此使用线程是有益的

**经典的线程模型**
理解进程的一个角度是, 它用某种方法把相关的资源集中在一起. 进程拥有存放程序正文和数据以及其他资源的地址空间. 进程拥有一个执行的线程, 该线程中有: 一个程序计数器, 用来记录接着要执行哪一条指令; 若干寄存器, 用来保存变量; 一个堆栈, 用来记录执行历史(原文如此, 但我并不清楚什么叫执行历史, 通常堆栈保存的还是程序的数据).
总的来说, 进程用于把资源集中到一起, 而线程则是在cpu上被调度执行的实体.
线程给进程模型增加了一项内容, 即在同一个进程环境中, 允许彼此之间有较大独立性的多个线程执行. 在同一个计算机上并行运行的多个进程, 共享计算机的内存, 磁盘等资源, 而同一进程中的多个线程, 共享进程的地址空间和其他资源. 因此, 当我们的应用需要并行执行的时候, 尤其是并行任务需要数据交互的时候, 选择多线程是非常合适的.

![](/images/现代操作系统/进程和线程中的内容.png)

创建和退出线程与进程差不多, 但有2点是不同的:
1. 线程之间是平等的, 即使一个线程是由另一个线程创建出来的, 它们之间也不能认为是父子关系, 因为不会因为创建线程的退出而导致被创建的线程也退出
2. 线程可以通过yield调用主动放弃cpu而让另一个线程运行. 进程不会这样做, 因为进程之间是竞争关系. 而线程这样做是因为它和其他线程是合作关系, 它们都是由程序设计者设计出来完成同一目标的. 通常线程的yield是为了等待其他线程完成某些任务.

**在用户空间中实现线程**

![](/images/现代操作系统/用户级和内核级线程.png)

好处:
1. 调度线程只需要在本地完成, 不需要陷入内核, 效率高
2. 允许每个进程有自己定制的调度算法
缺点:
1. 不容易实现系统级阻塞, 比如让线程读取键盘输入, 如果让线程实际进行该系统调用就会停止所有线程
2. 不容易处理页面故障. 所谓页面故障就是当程序不是一次性全部加载到内存中而在程序执行过程中跳转到了不在内存上的指令, 此时操作系统会去磁盘上找到这条指令(和它的邻居们)并加载到内存上. 因为内核感知不到用户级线程, 所以当某个线程触发页面故障时, 会导致整个进程被阻塞, 但实际上其他线程是可以运行的
3. 在一个单独的进程内部, 没有时钟中断, 所以不能使用轮转调度的方式调度线程

**在内核中实现线程**
好处和坏处与上面反一下.

**混合实现**
编程人员决定使用内核线程还是用户线程, 内核只识别内核级线程, 并对其进行调度, 其中一些内核级线程会被多个用户级线程多路复用(这个描述就很模糊, 不明白)

**调度程序激活机制**
听起来很拗口, 而且原文篇幅不少, 但总结起来就是, 内核去调用用户级的运行时系统(这个系统是用来调度线程的). 当线程触发了某些系统阻塞(上面介绍过的键盘输入和页面故障)后, 由内核去通知用户级的调度系统挂起该线程, 当阻塞过去, 也由内核去通知用户级的调度系统之前那个线程可以跑了. 当然, 如果线程没有引起系统阻塞, 那就跟用户级线程一样.
好处显而易见, 坏处就是违反了分层次系统内在结构的概念, 简单说就是调用应该是单向的, 一方向另一方提供服务供其调用, 而不能双方互相调用. 听起来无伤大雅, 但其实很伤, 这对整个系统的架构产生了一定的混乱, 不够清晰, 为实现和维护增加了难度.

**弹出式线程**
这是一种特殊的线程, 使用的典型场景是处理到来的消息. 当消息到达时, 创建一个处理该消息的线程, 因为它总是全新的, 因此可以为它优化创建过程, 使它能快速创建, 并能在内核中立即执行. 当然, 这么做的代价就是, 如果它出错会比用户级线程造成更大的损害.

**使单线程代码多线程化**
除了要考虑读写问题外, 这一节还提醒我们有些库就不是为多线程设计的, 即线程不安全, 通常来说文档里都会写.
以我的经验来说, 我更多的会去考虑多线程化的目的, 通过目的来决定需不需要多线程化, 和怎么去多线程化.
首先, 有2中典型的需要多线程的情景:
1. 执行某些阻塞调用, 如等待信号, 执行时间很长的计算等, 如果还有其他任务不能接受被阻塞, 如GUI界面, 那么这些调用应该被放到别的线程中
2. 充分利用多核cpu来进行并行计算. 这里需要考虑的就是如何充分利用可用的核使计算时间最短. 显然无限多的线程不能带来无限短的计算时间, 计算过程本身也不一定能够如此完全的并行, 总有必须顺序执行的部分. 一般来说, 把可以并行的计算拆分到与核数一致或少于核数的线程中, 每个线程的计算过程相同, 只是数据不同. 当然, 如果每个线程的计算很少, 那就宁愿少用一些线程甚至不用多线程, 因为线程的创建和退出也是有开销的.

-------

## 进程间通信
有3个关于进程间通讯的问题:
1. 进程如何把信息传递给另一个进程
2. 如何保证进程间的操作不会打架
3. 如何在需要时保证进程的执行顺序

对于第一个问题, 线程天然就解决了, 因为线程间共享地址空间. 第二和第三个问题在线程中也存在, 之后对于进程的问题讨论也同样适用于线程.

### 消息传递
首先解决第一个问题.
通过我查询的一些资料, 至少有以下几种手段可以实现进程间的消息传递:
1. 本地TCP通信:
很好理解, 两个进程一个做服务端, 一个做客户端, 握手后在本地同一个端口收发信息就行了.
2. 管道:
管道在UNIX中使用得非常普遍. 比如找到所有java进程
```bash
ps -ef | grep java
```
`|`之前的`ps -ef`列出了所有进程信息, 之后的`grep java`是选择出含有java的信息. 前者的输出作为了后者的输入, 是典型的进程间通信.

```c
#include<stdio.h>
#include<unistd.h>

int main()
{
    int fd[2];  // 两个文件描述符
    pid_t pid;
    char buff[20];

    if(pipe(fd) < 0)  // 创建管道
        printf("Create Pipe Error!\n");

    if((pid = fork()) < 0)  // 创建子进程
        printf("Fork Error!\n");
    else if(pid > 0)  // 父进程
    {
        close(fd[0]); // 关闭读端
        write(fd[1], "hello world\n", 12);
    }
    else
    {
        close(fd[1]); // 关闭写端
        read(fd[0], buff, 20);
        printf("%s", buff);
    }

    return 0;
}
```
这个是用c代码实现父子进程用管道通信
3. 消息队列:
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
    long mtype;
    char mtext[256];
};

int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;

    // 获取key值
    if((key = ftok(MSG_FILE,'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 打印key值
    printf("Message Queue - Server key is: %d.\n", key);

    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 打印消息队列ID及进程ID
    printf("My msqid is: %d.\n", msqid);
    printf("My pid is: %d.\n", getpid());

    // 循环读取消息
    for(;;)
    {
        msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
        printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
        printf("Server: receive msg.mtype is: %d.\n", msg.mtype);

        msg.mtype = 999; // 客户端接收的消息类型
        sprintf(msg.mtext, "hello, I'm server %d", getpid());
        msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
    }
    return 0;
}
```
其中主要就是
```c
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```
4. 共享内存:
系统提供的可以供多个进程读写的内存, 也很好理解, 不同的系统实现和接口不一样, 但思想是一样的, 用关键字来区分和访问不同的内存块. 

### 竞争
多个进程或线程访问同一块数据, 当时序不能保证时, 一定会带来读写问题, 即一个在读或者写, 但还没读写完, 就被另一个写了, 导致出错.
对于这块数据, 我们称之为临界区. 为了避免发生临界区的竞争, 同时保证使用共享数据的并发进程能够正确和高效地进行协作, 我们的解决方案需要满足一下4个条件:
1. 任何两个进程不能同时处于其临界区
2. 不应对cpu的速度和数量做任何假设
3. 临界区外运行的进程不得阻塞其他进程
4. 不得使进程无限期等待进入临界区

![](/images/现代操作系统/临界区.png)

**忙等待的互斥**
```c
#define FALSE   0
#define TRUE    1
#deinfe N       2

int turn;
int interested[N];

void enter_region(int process)
{
    int other;
    other = 1 - process;
    interested[process] = TRUE;
    turn = process;
    while (turn == process && interested[other] == TRUE);
}

void leave_region(int process)
{
    interested[process] = FALSE;
}
```
以上是1981年 G. L. Peterson发现的互斥解法. 可以看到, 在进入临界区时, 如果另一个进程正在使用这个临界区, 那么就会一直陷入`while (turn == process && interested[other] == TRUE)`循环, 这就是忙等待.
虽然它可以保证不会有超过1个进程进入临界区, 但是这个`while`循环浪费了cpu的资源, 并不是我们钟意的解法.

**睡眠与唤醒**
`sleep`和`weakup`是两个系统调用, 前者将进程挂起, 后者将挂起的进程唤醒使之可以继续执行.
以生产者-消费者模型为例:
```c
#define N 100
int count = 0;

void producer(void)
{
    int item;
    while (TRUE)
    {
        item = produce_item();
        if (count == N) sleep();
        insert_item(item);
        count = count + 1;
        if (count == 1) wakeup(consumer);
    }
}

void consumer(void)
{
    int item;
    while (TRUE)
    {
        if (count == 0) sleep();
        item = remove_item();
        count = count - 1;
        if (count == N - 1) wakeup(producer);
        consume_item(item);
    }
}
```
缓冲区满了后, 调用sleep挂起生产者进程, 当缓冲区从空加入新数据, 唤醒消费者进程, 而消费者进程在缓冲区为空时挂起自己, 在缓冲区从满到不满时唤醒消费者进程.
但它仍有问题, 就是`count`这个变量. 它仍有可能在不恰当的时机被修改导致生产者进程和消费者进程都休眠而无法唤醒. 例如在消费者进程检测到`count`为0时, 即将挂起自己, 但此时生产者将`count`修改为1, 并去唤醒消费者, 因为消费者本身就没有被挂起, 因此该唤醒被忽略, 但此时消费者仍然执行了`sleep`, 于是消费者永远被挂起, 生产者在写满缓冲区后也永远被挂起了.
即使我们修改上面的代码, 在`count`不为0时就尝试去唤醒消费者, 在`count`小于`N`时就去唤醒生产者, 也不能正真解决这个问题, 因为只要`count`这个变量能够在任意时刻被修改, 就会遇到在消费者`sleep`之前耗尽缓冲区而不再发出`wakeup`调用的情况.
所以, 我们需要保证, `count`的检测和`sleep`, `wakeup`之间是不可分割的. 这样就引入了下一节:

**信号量**
1965年E. W. Dijkstra提出信号量, 它使用一个整形变量来累计唤醒次数. 一个信号量的值可以为0(表示没有保存下来的唤醒操作)或为正值(表示有一个或多个唤醒操作).
Dijkstra建议设立两种操作: `down`和`up`. 
对一信号量执行`down`操作, 会检查其值是否大于0, 若大于0, 则将其减1; 若等于0, 则将进程挂起(有点像引用计数), 并在重新唤醒后再进行减1操作. 
对一信号量执行`up`操作, 会使其值加1. 如果1个或多个进程在该信号量上睡眠, 则由系统选择一个唤醒, 唤醒的进程会继续完成down操作.

**互斥量**
如果不需要信号量的计数能力, 可以使用一个简化版本, 互斥量(mutex).
互斥量是一个可以处于两种状态之一的变量: unlocked和locked. 典型的使用场景是当进程需要访问临界区时, 调用`mutex_lock`, 如果该互斥量是unlocked, 则对其加锁, 并进入临界区, 如果该互斥量是locked, 则进程被阻塞, 直到有进程调用`mutex_unlock`, 此时若有多个进程被该互斥量阻塞, 则随机选择一个进程唤醒, 并加锁.
下面我们来看一下用pthread库中的互斥量来实现生产者消费者模型:
```c++
#include <stdio.h>
#include <pthread.h>
#define MAX 1000000000
pthread_mutex_t the_mutex;
pthread_cond_t condc, condp;
int buffer = 0;

void *producer(void *ptr)
{
    for (int i = 1; i <= MAX; i++)
    {
        pthread_mutex_lock(&the_mutex);
        while (buffer != 0) pthread_cond_wait(&conp, &the_mutex);
        buffer = i;
        pthread_cond_signal(&condc);
        pthread_mutex_unlock(&the_mutex);
    }
    pthread_exit(0);
}

void *consumer(void *ptr)
{
    for (int i = 1; i < MAX; i++)
    {
        pthread_mutex_lock(&the_mutex);
        while (buffer == 0) pthread_cond_wait(&condc, &the_mutex);
        buffer = 0;
        pthread_cond_signal(&condp);
        pthread_mutex_unlock(&the_mutex);
    }
}

int main(int argc, char **argv)
{
    pthread_t pro, con;
    pthread_mutex_init(&the_mutex, 0);
    pthread_cond_init(&condc, 0);
    pthread_cond_init(&condp, 0);
    pthread_create(&con, 0, consumer, 0);
    pthread_create(&pro, 0, producer, 0);
    pthread_join(pro, 0);
    pthread_join(con, 0);
    pthread_cond_destroy(&condc);
    pthread_cond_destroy(&condp);
    pthread_mutex_destroy(&the_mutex);
}
```
`pthread_cond_wait`会让当前线程阻塞并解锁互斥量, 而`pthread_cond_signal`则会唤醒前者并让前者的互斥量加锁. 
至此, 我们的生产者-消费者模型终于能用了.

**管程**
管程(monitor)是一个语言概念, 它保证在管程中的一段代码在同一时间只能有1个活跃进程, 这是由编译器保证的.

![](/images/现代操作系统/管程.png)

然而c语言并不支持管程, 我也不清楚哪种语言有这个特性, 所以就不详细介绍了.

**屏障**
屏障(barrier)是进程组用来同步的机制.

![](/images/现代操作系统/屏障.png)

这个在并行计算中使用得非常普遍, CUDA中也有这个概念. 比如我们要进行2次矩阵乘法运算, 我们将矩阵乘法拆分成一个进程或线程计算一行和一列的点乘. 那么我们就需要在第一次乘法和第二次乘法之间设置一个屏障, 当第一次乘法的所有进程或线程计算完毕后才能再开始第二次乘法运算, 如果不这么做, 第二次计算就会使用错误的值.

**避免锁**
虽然锁给我们在多进程和线程合作中带来的方便, 但我们也要知道, 使用锁是有代价的. 为了性能, 我们应该尽量避免使用锁.
有时候, 我们在读数据的时候, 并不在意当前读到的值是否是最新的, 只要是正确和完整的值就能接受. 比如周期备份的日志, 也许正在有一条新的日志写进来, 但这一次的备份没必要去等它, 因为它在下个周期时总能被备份. 但尽管不需要等它, 我们在备份时, 不能保存一条写了一半的日志. 在这种情况下, 我们可以使用读-复制-更新(Read-Copy-Update, RCU)的方法.

![](/images/现代操作系统/读-复制-更新.png)

写日志的进程在写完一条数据之前不会修改备份进程读到的数据, 直到写完一条, 将其更新到实际日志中, 这个更新操作是原子的, 这比使用锁的代价小多了.

## 调度
当2个或更多的进程处于就绪状态时, 我们就需要选择下一个要运行的进程, 完成选择工作的这一部分称为调度程序(scheduler), 该程序使用的算法称为调度算法.

**进程行为**
有些进程花费了绝大多数时间在计算上, 有些则在等待I/O上, 前者我们称为计算密集型, 后者称为I/O密集型. 

![](/images/现代操作系统/进程行为.png)

有必要指出, 随着cpu变得越来越快, 更多的进程倾向为I/O密集型, 这是因为cpu的改进比磁盘改进快的多, 这导致未来对I/O密集型进程的调度处理似乎更为重要. 基本原则是, 如果需要运行I/O密集型进程, 那么就应该让它尽快得到机会, 以便发出磁盘请求并保持磁盘始终忙碌.

**何时调度**
有关进程调度处理的一个关键问题是何时进行调度决策, 有以下几种情形:
1. 在创建一个新进程后
2. 在一个进程退出后
3. 当一个进程阻塞时
4. 当一个I/O中断发生时
前3个比较好理解, 这里说明一下第4个. I/O中断发生在I/O设备完成工作时, 此时被阻塞的等待该I/O的进程从阻塞变为了就绪, 那么调度程序就要决定是继续阻塞这个进程还是挂起当前线程唤醒这个阻塞的进程.

**调度算法分类**
1. 非抢占式:
一个进程会一直运行到它自己退出或被阻塞, 即使它运行了若干小时, 也不会被强迫挂起, 在一个进程退出或被阻塞时, 通常按照优先级在进程队列里选择优先级最高的进程运行
2. 抢占式:
每个进程只能运行一小段固定时间(时间片), 如果该时间结束时进程还在运行, 则该进程会被挂起, 调度程序会挑选另一个进程运行. 这么做的前提是时钟中断发生在时间片结尾. 如果没有时钟, 那么就只能使用非抢占式的方法了.

对不同的环境需要使用不同的调度算法. 我们大致把环境分为3种:
1. 批处理:
批处理系统在商业领域仍广泛应用, 用来处理薪水册, 存货清单, 帐目收入等周期性作业, 它们不会有用户不耐烦地在终端旁等待. 因此, 非抢占式算法, 或对每个进程都有长时间周期的抢占式算法通常都是可接受的. 这个处理方法减少了进程的切换从而改善了性能.
2. 交互式
在交互式用户环境中, 为了避免一个进程霸占cpu, 抢占是必须的, 如服务器和我们日常所用的pc
3. 实时
在有实时限制的系统中, 抢占有时是不需要的, 因为进程了解它们可能会长时间得不到运行, 所以通常很快地完成各自的工作并阻塞. 实时系统通常是专用的, 只运行用来推进现有应用的程序, 这些程序的行为都是可预测的, 因此可以不需要抢占.

**调度算法的目标**

![](/images/现代操作系统/调度算法目标.png)

**批处理系统中的调度**
1. 先来先服务(first-come first-served)
优点: 易于理解, 便于实现
缺点: 未对不同类型的进程进行调度优化, 吞吐量, 周转时间, cpu利用率均不是最优
2. 最短作业优先(shortest job first):
当可以预知进程运行时间时, 优先运行时间最短的进程
优点: 当所有作业都可运行的情形下, 周转时间最优
缺点: 需要能够预知进程的运行时间. 
3. 最短剩余时间优先(shortest remaining time next)
抢占式的最短作业优先, 调度程序总是选择剩余运行时间最短的进程运行
优点: 当有新来的短时间进程就绪, 比最短作业优先的方法周转时间更短
缺点: 需要能够预知进程的运行时间. 

**交互式系统中的调度**
1. 轮转调度:
每个进程被分配一个时间段, 称为时间片(quantum), 当进程在时间片结束时还未运行完毕, 则强制剥夺cpu并分配给另一个进程.
我们知道进程的切换是有代价的, 假设切换进程需要1ms, 而我们的时间片长度为4ms, 则cpu将会有20%的时间浪费在了管理开销上, 这显然是不划算的(想起了苏妈说的MIT的phd给哈佛的mba打工). 但如果时间片设定过长, 则进程的等待时间也会变长, 这将会引起用户的不满, 这也是我们不愿意看到的.
所以结论就是, 时间片太短会导致过多的进程切换, 降低了cpu的效率, 而太长的话则又会引起交互请求响应时间变长. 将时间片设为20~50ms通常是一个比较合理的折中. (原书似乎是2015年出版的, 这个"20~50ms"对于现在来说我也不知道合不合适)

2. 优先级调度:

![](/images/现代操作系统/优先级调度.png)

图中给出了一个有4类优先级的系统, 它会按照优先级的高低在同级内实行轮转调度, 当优先级高的执行完毕后, 才会轮到优先级低的进程. 显然, 如果不偶尔对优先级进行调整, 低优先级的进程很可能会产生饥饿现象.

3. 多级队列(Compatible Time Sharing System):
为了减少进程切换带来的损耗, 多级队列策略在进程被切换后再次执行时分配给该进程较之上次双倍的时间片, 并降低优先级. 这样做可以兼顾响应时间, 为那些运行时间短的进程能够尽快完成.
对于那些刚开始运行一段长时间, 而后来又需要交互的进程, 为了防止其永远处于被惩罚状态, 在终端上有回车键按下时, 则属于该终端的所有进程就都被移到最高优先级. 但这样做其实有被滥用的风险, 因为用户有可能会发现, 只要在自己的终端每隔几秒敲一下回车键就可以大大提高响应时间, 如果这个经验被广泛传播出去, 那么这个策略可能就失效了.

4. 保证调度:
向用户作出明确的性能保证, 比如用户将获得cpu处理能力的1/n.

5. 彩票调度:
其基本思想是为进程提供各种系统资源(如cpu时间)的彩票. 一旦需要做出一项调度决策时, 就随机抽出一张彩票, 拥有该彩票的进程获得该资源.

**实时系统中的调度**
实时系统是一种时间起着主导作用的系统. 典型地, 一种或多种外部物理设备发给计算机一个服务请求, 而计算机必须在一个确定的时间范围内恰当地做出反映. 例如cd播放器, 病人监护装置, 飞机的自动驾驶系统, 自动化工厂中的机器人控制. 在所有的这些例子中, 正确的但是迟到的应答往往比没有还要糟糕.

实时系统通常可以分为硬实时和软实时. 前者必须满足绝对的截止时间, 后者对错失截至时间有一定的容忍性.

## 经典的IPC问题
**哲学家就餐问题**
这个问题在1965年由Dijkstra提出(又是他!). 这个问题可以简单地描述如下: 
5个哲学家围坐在一张圆桌周围, 每个哲学家面前都有一盘通心粉, 需要两把叉子才能进餐, 相邻的2个盘子之间放有1把叉子. 哲学家有2中活动状态: 吃饭和思考. 当哲学家饿了的时候, 他就会试图去取其左边和右边的叉子, 每次拿1把, 但不分次序, 如果拿到了2把, 就可以吃饭. 需要解决的问题是: 能为每一位哲学家写一段描述其行为的程序并保证不会死锁吗?
![](/images/现代操作系统/哲学家就餐问题.png)

从那时起, 每个发明新的同步原语的人都希望通过解决哲学家就餐问题来展示其同步原语的精妙之处.

```c++
#define N           5
#define LEFT        (i+N-1)%N
#define RIGHT       (i+1)%N
#define THINKING    0
#define HUNGRY      1
#define EATING      2

typedef int semaphore;
int state[N];
semaphore mutex = 1;
semaphore s[N];

void philosopher(int i)
{
    while (true)
    {

    }
}

void take_forks(int i)
{
    down(&mutex);
    state[i] = HUNGRY;
    test(i);
    up(&mutex);
    down(&s[i]);
}

void put_forks(int i)
{
    down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(int i)
{
    if (state[i] == HUNGRY && 
        state[LEFT] != EATING && 
        state[RIGHT] != EATING)
    {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

以上的这段代码是哲学家就餐问题的一种解法, 它保证一个哲学家只有在两个邻居没有进餐时才允许进入到进餐状态.

**读者-写者问题**
简单来说就是需要实现当一个进程在写的时候不允许其他的读写, 但一个进程在读的时候可以允许其他进程读.
这个问题就不给出代码实现了, 很多框架都提供这样的读写锁, 或者直接对自己的数据结构实现了读写锁.

------
第二章差不多就是这些了, 内容可真不少, 不过也难怪, 进程和线程是操作系统中非常基础但十分重要的概念. 
某些编程语言中(如Go)还有协程的概念, 它是完全在用户态中由应用程序自己实现的伪并行. 所以它确实不属于操作系统的范畴.

之后我可能不会按顺序读下去了, 我会挑选我感兴趣的章节继续记录.

2020/06/17