---
title: 现代操作系统 第一章 引论
top: false
cover: false
toc: true
mathjax: true
date: 2020-03-09 11:38:28
password:
summary:
tags:
categories: 操作系统
thumbnail:
---

为了督促自己读书，开个坑吧。
现在在读的是《现代操作系统第四版》，作为一个没学过操作系统的coder，去了解一下这方面的知识还是挺有必要的。这本书很厚，看了下目录有五百多页，我可能看得不会面面具到，但我会把对我有用的一些基础知识记录下来，这个系列算是我对这本书的读书笔记吧。

引论部分讲的是对操作系统整体的概念。
首先，什么是操作系统？
<!--more-->
原文中给出的不准确的定义是：操作系统是一种运行在内核态的软件。这说的让人一头雾水。内核态是计算机的一种运行模式，在该模式下，操作系统对具有对硬件的完全访问权，可以执行机器能够运行的任何指令。与之相对的是用户态，通常用户程序，也就是计算机使用者运行的各种软件，是跑在这个环境下的，用户程序所能使用的指令是内核态能用指令的子集。
如果从操作系统的功能来描述的话，可能更好理解一些。如下图，操作系统就是在用户程序和硬件驱动之间的中间层。
![](/images/现代操作系统/操作系统所处的位置.png)
这个中间层，不光要提供接口，同时也要负责管理计算机的各种资源，比如计算资源处理器，文件资源硬盘，内存资源和各种IO设备。

--------------

接下来是操作系统的历史，从无到有到复杂，主要是因为硬件在不断的发展，标准在后来在逐渐设立。
然后是计算机的硬件组成：

**计算单元cpu**
即使是不太懂电脑的人也知道计算机中有这么一块芯片，主要负责计算机的逻辑和运算。从硬件上来说，一块cpu中，除了运算单元外，还有寄存器和缓存。其中寄存器是读写速度最快的，相应的容量也最小，然后是L1缓存，L2缓存，甚至L3缓存，它们的速度依次降低，容量依次变大。缓存的作用就是节省读内存的时间，即使我们知道，读内存已经比读磁盘快得多，但这还是要走内存总线，但缓存是在cpu内的，显然这快得多。
![](/images/现代操作系统/cpu缓存.png)
图中前者为Intel的结构，L2缓存核间共享，后者为AMD的结构，L2缓存是独立的，各有优劣。
另外，cpu有两种指令执行模式，流水线（pipeline）和超标量。
![](/images/现代操作系统/cpu指令执行模式.png)
流水线我之前就有了解过，cpu并非一次只加载一条指令，而是多条指令，这样能减少cpu取指令时的空闲时间。我去了解这个知识是因为发现在for循环中加入条件判断会影响执行速度，在google之后知道了是因为在if判断的时候，cpu并不会先去执行判断条件，而是会猜测结果构建流水线，如果cpu总是猜错，那么流水线在执行完毕后，还要回头再执行另一条分支。
超标量这种方法就是新知识了，我没有深入了解过，不太清楚什么场景下会用到，它有点像交换机排队发包的感觉。

**存储器**
在cpu中已经提到了，寄存器、缓存、内存和磁盘，它们速度一个比一个慢，容量一个比一个大，价格一个比一个便宜。
![](/images/现代操作系统/存储结构.png)
操作系统对于它们的管理是非常重要的一个部分，也十分复杂，这部分会在后面的章节详细说明。

**I/O设备**
I/O设备一般包括两个部分：设备控制器和设备本身。我们常用的鼠标键盘就是典型的I/O设备。有三种种策略去控制I/O设备，一是轮询，就是cpu不断问设备“你好了没有，你好了没有，你好了没有...”，显然，这样会占用cpu大量时间。二是中断，就是cpu给I/O设备布置任务，设备完成后发出中断通知cpu，在此期间cpu是未被占用的。第三种我不太熟悉，使用了DMA芯片，由该芯片管理中断。

**总线**
我记得之前上学的时候还听过南桥北桥的概念，但在这里并未提及。
![](/images/现代操作系统/总线.png)
从图中来看，总线其实就是连接cpu与其他设备的线，比较耳熟能详的有PCIe和USB。

**BIOS**
在硬件上，它储存在一块ROM上，主要是用来做开机硬件检查和启动真正的操作系统的。

------------

接下来是操作系统概念和抽象，这部分基本上就是全书的内容了。这里只是做一个介绍。
**进程**
进程的本质是正在执行的一个程序。与进程相关的一个重要概念是地址空间，进程可以进行读写，其内部存放有可执行程序，程序数据，程序堆栈。另外还有寄存器，打开文件清单等。进程基本上是容纳运行一个程序所需要的所有信息的容器。
一个现代的操作系统需要处理多个进程运行的情况，我们知道cpu同一时间只能处理一条指令，为了让计算机能同时运行多个进程，操作系统必须在不同进程间来回切换以达到“同时”运行的效果。这里面的策略在这里就不展开了。

**地址空间**
较复杂的操作系统允许在内存中同时运行多道程序，为了避免相互干扰，每个进程拥有自己的地址空间，这种机制是硬件形式的，但由操作系统掌控。
虚拟内存可以让操作系统拥有比物理容量更大的内存，实际上是用硬盘上的空间映射到内存地址上。

**文件**
文件系统其实是普通用户最能体验到不同操作系统区别的地方。
Windows有cdef盘，我印象中物理上的硬盘可以分为Windows文件系统中不同的盘，但物理上不同的硬盘不能并为windows中的一个盘。
Linux的文件系统是一个树，不管物理上有多少硬盘，都是在根目录下的。
从用途上来说，文件系统提供了硬盘的抽象，用户程序不必去烦恼如何在硬盘中找到自己想要的数据，而是根据文件系统的目录，去读写文件。
在Unix中，有特殊文件，通常是I/O设备，比如打印机，用户直接写这些特殊文件来操作设备。
还有就是管道（pipe）。它是一种虚文件，用于进程间通信。

**输入/输出**
每个操作系统都有管理其I/O设备的子系统，用来对计算机进行输入（键盘按键，鼠标点击），输出（显示器图像，音频）。

**保护**
这里的保护指用户文件权限和其他计算机安全性问题。

---------

**系统调用**
接下来讲的是一些常见的系统调用，但这对于我一个初学者来说不是很友好，因为前面的概念都没有足够的了解，直接介绍了fork和read等系统调用，看了和没看差不多。这里就贴一张在UNIX和Windows中常见的一些系统调用吧。
![](/images/现代操作系统/系统调用.png)

需要特别说明的是，Windows一栏列出来的叫Win32 API，调用这些接口可能不全都是在内核态完成的，并且随着Windows版本的不同，它们的实现可能也会发生变化。

---------
下面是操作系统结构的大类，我就捡我感兴趣的两个写一下。
**微内核**
微内核是相对与单内核或者叫宏内核来说的。它们之间的区别在于，前者将操作系统划分为小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态。这样做的好处是，即使其他模块崩了，系统不会崩，而因为其微内核小，错误自然也会少。而后者虽然也可能会将操作系统划分成若干模块，但它们都会跑在内核态，这样的好处是效率高，系统服务没有用户态和内核态转换开销。
大多数Linux都是宏内核操作系统，这符合它实用至上的原则。Windows和OS X是微内核操作系统，但它们并不纯粹，很多服务还是跑在内核态以此提高运行效率，所以我们能看到经典的Windows蓝屏。

**虚拟机**
虚拟机这个词耳熟能详，我们常见的有VMware、VirtualBox和KVM。但它们似乎都只是应用程序一样的东西。早期第一代虚拟机，实际相当于操作系统，它跑在裸机上，向上层提供了若干台“虚拟”机。它不同于其他操作系统的地方是：这些虚拟机不是那种具有文件等优良特征的扩展计算机，而仅仅是裸机硬件的精确复制品。而第二代虚拟机，也就是我们上面提到的几个，实际上叫虚拟机管理程序，它们利用宿主操作系统的文件系统创建进程、存储文件。
另外提到的是Java虚拟机JVM。学过Java的人知道，Java号称"Compile once, run everywhere."Java之所以能做到这样，是因为Java代码编译成了JVM解释器可执行的代码，只要目标机器安装了JVM，JVM代码就可以运行。

--------
第一章差不多就是这样，最后还有一些c语言相关的知识，就不在这里复述了。

2020/03/26