---
title: 现代操作系统-第三章-内存管理
top: false
cover: false
toc: true
mathjax: true
date: 2020-09-10 09:43:36
password:
summary:
tags:
categories: 操作系统
thumbnail:
---

虽然上一章说要挑自己感兴趣的看，但发现知识储备并不支持我这么做，所以还是按顺序看了下去。

内存（RAM）是计算机中重要且基本的一个组成部分，需要认真管理。每个程序员都梦想拥有这样的存储器：它是私有的、内容无限大的、速度无限快的、永久性的（即断电时不会丢失数据），并且价格低廉。遗憾的是，目前这样的存储器还不存在。现实中，我们使用的是分层存储器体系（memory hierarchy）的概念。
在这个体系中，计算机有若干MB快速、昂贵且易失的高速缓存（cache），若干GB速度与价格适中但易失的内存，以及若干TB低速、廉价、非易失的磁盘存储，另外还有U盘和记忆卡等可移动存储装置。操作系统的工作是将这个存储体系抽象为一个有用的模型并管理这个抽象模型。
操作系统中管理分层存储体系的部分称为存储管理器（memory manager）。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。

<!--more-->

## 无存储器抽象
最简单的存储器抽象就是根本没有抽象，即每个程序都直接访问物理内存。
在这种情况下，想要在内存中同时运行两个程序是不可能的。如果第一个程序在2000的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，因为程序直接指定了物理内存的位置，所以同时运行两个程序行不通。

不过也存在一些变通的方法。

![](/images/现代操作系统/系统进程和用户进程使用不同的内存位置.png)

这样的变通方法允许操作系统进程运行的同时，再运行一个用户进程。第一种方案以前被用在大型机和小型计算机上，现在很少使用了。第二种方案被用在一些掌上电脑和嵌入式系统中。第三种方案用于早期的个人计算机中（例如运行MS-DOS的计算机），在RAM中的系统部分称为BIOS（Basic Input Output System）。第一种和第三种方案的缺点是用户程序出现的错误可能摧毁操作系统，引发灾难性的后果。
在没有存储器抽象的系统中实现并行的一种方法是使用多线程来编程。虽然这个想法行得通，但没有被广泛使用，因为人们通常希望能够在同一时间运行没有关联的程序，而这是线程抽象所不能提供的。

**在不使用存储器抽象的情况下运行多个程序**
更进一步的方法是，将当前内存中所有内容保存到磁盘文件中，然后把下一个程序读入内存运行，只要同一时间中只有一个程序在运行，就不会发生冲突。这么做的弊端是显而易见的，慢，但是这个交换的思想在后面会继续讨论。
另外是借助特殊的硬件来实现。IBM 360的早期模型是这样解决的：内存被划分为2KB的块，每一块被分配一个4位的保护键，保护键存储在CPU的特殊寄存器中。运行中的程序如果访问了不属于它的内存地址，那么该地址的保护键和程序状态字中的保护键就会冲突，360的硬件就会捕获到这一事件，从而防止进程之间互相干扰。
然而，这仍然没有解决程序访问绝对物理地址而造成互相之间冲突的问题。IBM 360使用静态重定位技术：当一个程序被装载到地址16384时，常数16384会被加到每一个程序地址上。但这不是一种通用的解决方法，同时会减慢装载速度，而且它要求给所有的可执行程序提供额外的信息来区分哪些内存字中存有（可重定位的）地址，哪些没有，比如
```
MOV REGISTER1, 28
```
这样把数28送到REGISTER1的指令不可以被重定位。

虽然直接引用物理地址对于大型计算机、小型计算机和个人电脑来说已经是很久远的记忆了，但是这种缺少存储器抽象的情况在嵌入式系统和智能卡系统中还是很常见的，比如收音机、洗衣机、微波炉这样的设备已经完全被（ROM形式的）软件控制，因为它们运行的所有程序都是可以事先确定的。

## 一种存储器抽象：地址空间
把物理地址暴露给进程会带来以下几个严重问题：
1. 如果用户程序可以访问内存的每个地址，那么它们就可以很容易地破坏操作系统，造成系统崩溃
2. 同时运行多个程序是非常困难的，而这种需求十分常见
因此，我们需要想想其他办法。

### 地址空间的概念
要使多个应用程序同时处于内存中且相互不影响，需要解决两个问题：保护和重定位。一个比IBM 360使用的静态重定位技术更好的方法是创造一个新的存储器抽象：地址空间。
就像进程的概念创造了一类抽象的CPU以运行程序一样，地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有自己的地址空间，并且这个地址空间独立于其他进程的地址空间。

**基址寄存器与界限寄存器**
这个简单的解决办法是使用动态重定位，简单地把每个进程的地址空间映射到物理内存的不同部分。我们为每个CPU配置两个特殊的硬件寄存器，通常叫做基址寄存器和界限寄存器。
当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空闲位置且装载过程中无需重定位

![](/images/现代操作系统/基址寄存器和界限寄存器.png)

每次进程访问内存，取一条指令，读或者写一个数据字，CPU硬件会把地址发送到内存总线前，自动把基址寄存器中的值加到该地址值上，同时检查它是否等于或大于界限寄存器中的值。这样，对于图中白色部分的程序第一条指令
```
JMP 28
```
就会被硬件解释成
```
JMP 16412
```
这样，程序就如我们所愿地跳转到了CMP指令。
使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算，比较运算可以很快，但加法运算在没有使用特殊电路的情况下会显得很慢。

### 交换技术
如果计算机物理内存足够大，那么之前所提及的所有方案多多少少是可行的，但实际上，内存总是不够用。一个典型的Windows、OS X或Linux系统，在计算机完成引导后会启动50～100个甚至更多的进程，而仅仅一个Photoshop用户程序一启动就轻易地占据了500M内存，而开始处理数据后可能需要数GB的空间。因此，把所有进程保存在内存中需要巨大的内存，如果内存不够，就做不到这一点。
有两种处理内存超载的通用方法。最简单的策略是交换（swapping）技术，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。另一种策略是虚拟内存（virtual memory），该策略甚至能使程序在只有一部分被调入内存的情况下运行。
下面讨论交换策略。

![](/images/现代操作系统/交换内存.png)

交换在内存中产生了多个空闲区（hole，也称为空洞），通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块，该技术被称为内存紧缩（memory compaction），通常不进行这个操作，因为很费CPU时间。
如果进程在创建后所需内存大小不变，则分配时很简单，系统按需分配就是了，但是如果进程在运行时试图增长，就会导致问题。如果该进程相邻区域空闲，则可以扩大它的空间，若其相邻区域已被其他进程占据，则需要将其移动到一块内存中足够大的区域去，若内存已满，则需要将若干其他进程换走，直到空出足够大的空间。显然，这么做很费时。

![](/images/现代操作系统/预留内存空间.png)

一种解决方法是在分配时预留一段供其增长的数据段。

### 空闲内存管理
在动态分配内存时，操作系统必须对其进行管理。一般而言，有两种方法跟踪内存使用情况：位图和空闲链表。

**使用位图的存储管理**
位图法要求将内存划分成几个字节到几千字节的分配单元，每个分配单元对应位图中的一位，用0和1表示空闲和占用。

![](/images/现代操作系统/位图和链表.png)

分配单元的大小是一个重要的设计因素。分配单元越小，位图越大，实际可用内存就越小，但分配单元越大，浪费的内存也越大，因为只能分配整数个单元。
另外，在决定把一个占k个分配单元的进程调入内存时，存储管理器必须搜索位图，在位图中找出有k个连续0的串，这是个耗时的操作。

**使用链表的存储管理**
另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表。如上图c所示。
当系统要为进程分配内存时，会沿着链表进行搜索，直到找到一个足够大的空闲区。
最简单的算法是首次适配法（first fit），找到的第一个足够大的空间就供进程使用，该空间剩余的部分作为新的空闲区。首次适配法速度较快，因为它尽可能少地搜索链表结点。
另一个算法时最佳适配法（best fit），它搜索整个链表，选择能够容纳进程的最小的空闲区。它比首次匹配法要慢，因为搜索整个链表，但出乎意料的是，它反而比首次匹配法更浪费内存，因为它会产生大量无用的小空闲区域。
此时，作为一名刷过算法的程序员，能敏锐地察觉到对这两种算法有不少加速的可能，比如为进程和空闲区各自维护独立的链表，这样就能只检查空闲区链表。另外还能对链表排序，这样就进一步缩短了搜索的时间。
还有一种算法称为快速适配（quick fit），它为常用大小的空闲区维护单独的链表，比如4KB一个链表，8KB一个链表，以此类推，这样系统就可以根据需要，选择合适的大小来用。

## 虚拟内存
